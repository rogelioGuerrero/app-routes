"""solution_presenter.py
Presenta y valida la solución del VRP verificando las restricciones.
"""
import json

class JsonSolutionPresenter:
    """Presenta la solución del VRP en formato JSON verificando restricciones."""

    @staticmethod
    def present(raw_solution, request_data):
        """Procesa y presenta la solución del VRP."""
        # Obtener los datos del contenedor correcto
        # El request_data puede tener un campo 'data' o ser directamente los datos
        data = request_data.get('data', request_data)
        
        if not raw_solution or 'routes' not in raw_solution:
            return {
                "status": "error",
                "message": "No se encontró solución"
            }
            
        # Extraer datos importantes
        locations = data.get('locations', [])
        vehicles = data.get('vehicles', [])
        pickups_deliveries = data.get('pickups_deliveries', [])
        
        print(f"[DEBUG] Presenter - Vehículos disponibles: {len(vehicles)}")
        for i, v in enumerate(vehicles):
            print(f"[DEBUG] Vehículo {i}: ID={v.get('id')}, Peso={v.get('weight_capacity')}, Volumen={v.get('volume_capacity')}, Skills={v.get('skills')}")
        
        # Analizar demandas totales por clientes
        total_weight_demand = 0
        total_volume_demand = 0
        for loc in locations:
            if loc.get('type') != 'depot':  # No contar los depósitos
                weight_demand = loc.get('weight_demand', 0)
                volume_demand = loc.get('volume_demand', 0)
                # Solo sumar demandas positivas para evitar contar dos veces en pares pickup/delivery
                if weight_demand > 0:
                    total_weight_demand += weight_demand
                if volume_demand > 0:
                    total_volume_demand += volume_demand
        
        # Procesar rutas
        routes = []
        warnings = []
        capacity_warnings = []
        # --- Validación pickup-delivery ---
        # Construir mapa de ubicación a (vehículo, posición en ruta)
        node_to_vehiclepos = {}
        for i, route_data in enumerate(raw_solution.get('routes', [])):
            vehicle_id = route_data.get('vehicle_id', '')
            route_nodes = route_data.get('route', [])
            for pos, node in enumerate(route_nodes):
                loc_id = node.get('location_id')
                node_to_vehiclepos[loc_id] = (vehicle_id, i, pos)
        # Validar cada par pickup-delivery
        for pd in pickups_deliveries:
            pickup_id = pd.get('pickup')
            delivery_id = pd.get('delivery')
            if not pickup_id or not delivery_id:
                warnings.append(f"Par pickup-delivery inválido: {pd}")
                continue
            pickup_info = node_to_vehiclepos.get(pickup_id)
            delivery_info = node_to_vehiclepos.get(delivery_id)
            if not pickup_info or not delivery_info:
                warnings.append(f"Par pickup-delivery no atendido: pickup={pickup_id}, delivery={delivery_id}")
                continue
            if pickup_info[0] != delivery_info[0]:
                warnings.append(f"Pickup y delivery de par {pickup_id}->{delivery_id} están en vehículos distintos: {pickup_info[0]} y {delivery_info[0]}")
            elif pickup_info[2] >= delivery_info[2]:
                warnings.append(f"Pickup {pickup_id} ocurre después de delivery {delivery_id} en la ruta del vehículo {pickup_info[0]}")
        
        for i, route_data in enumerate(raw_solution.get('routes', [])):
            # Obtener el ID del vehículo
            vehicle_id = route_data.get('vehicle_id', '')
            
            # Encontrar el vehículo en los datos de entrada
            vehicle = None
            for v in vehicles:
                if v.get('id') == vehicle_id:
                    vehicle = v
                    break
            
            if not vehicle:
                warnings.append(f"Vehículo no encontrado: {vehicle_id}")
                continue
                
            # Capacidades del vehículo
            weight_capacity = vehicle.get('weight_capacity', 0)
            volume_capacity = vehicle.get('volume_capacity', 0)
            vehicle_skills = set(vehicle.get('skills', []))
            
            # Extraer nodos de la ruta y breaks
            route_nodes = route_data.get('route', [])
            route_breaks = route_data.get('breaks', [])
            
            # Añadir información de breaks a la salida
            if route_breaks:
                print(f"[DEBUG] Vehículo {vehicle_id} tiene {len(route_breaks)} breaks configurados")
                for i, brk in enumerate(route_breaks):
                    scheduled_start = brk.get('scheduled_start', 'No programado')
                    scheduled_end = brk.get('scheduled_end', 'No programado')
                    
                    # Formatear horas para mejor legibilidad
                    def format_time(seconds):
                        if isinstance(seconds, (int, float)):
                            h = int(seconds // 3600)
                            m = int((seconds % 3600) // 60)
                            return f"{h:02d}:{m:02d}"
                        return str(seconds)
                    
                    print(f"[DEBUG] Break {i+1}: {brk.get('id')}")
                    print(f"  • Duración: {brk.get('duration')}s ({brk.get('duration')/60:.1f} min)")
                    print(f"  • Ventana: {format_time(brk.get('earliest_start'))} - {format_time(brk.get('latest_start'))}")
                    print(f"  • Programado: {format_time(scheduled_start)} - {format_time(scheduled_end)}")
                    
                    # Verificar si el break está dentro de su ventana
                    if isinstance(scheduled_start, (int, float)):
                        if scheduled_start < brk.get('earliest_start', 0):
                            print("  • [ADVERTENCIA] El break comienza antes de la hora permitida")
                        elif scheduled_start > brk.get('latest_start', float('inf')):
                            print("  • [ADVERTENCIA] El break comienza después de la hora permitida")
            
            # Los nodos ya son objetos con información completa
            nodes = route_nodes
            if not nodes:
                continue
            
            # Calcular demandas acumuladas
            # Acumulación progresiva de demanda para verificar en cada nodo
            cumulative_weight = 0
            cumulative_volume = 0
            max_cumulative_weight = 0
            max_cumulative_volume = 0
            node_names = []
            missing_skills = []
            
            print(f"[DEBUG] Procesando ruta para vehículo {vehicle_id} con capacidad peso={weight_capacity}, volumen={volume_capacity}")
            print(f"[DEBUG] Nodos en ruta: {len(nodes)}")
            
            for node_data in nodes:
                # Los nodos ya son objetos con toda la información
                location_id = node_data.get('location_id')
                location_name = node_data.get('location_name')
                location_type = node_data.get('location_type')
                
                # Acumular demandas desde el objeto nodo
                weight_demand = 0
                volume_demand = 0
                
                # Buscar la ubicación original para obtener las demandas
                for loc in locations:
                    if loc.get('id') == location_id:
                        weight_demand = loc.get('weight_demand', 0)
                        volume_demand = loc.get('volume_demand', 0)
                        break
                
                cumulative_weight += weight_demand
                cumulative_volume += volume_demand
                
                # Seguir el máximo acumulado (para pickup-delivery puede variar)
                max_cumulative_weight = max(max_cumulative_weight, cumulative_weight)
                max_cumulative_volume = max(max_cumulative_volume, cumulative_volume)
                
                print(f"[DEBUG] Nodo {location_id} ({location_name}): Demanda peso={weight_demand}, Acumulado={cumulative_weight}/{weight_capacity}")
                print(f"[DEBUG] Nodo {location_id} ({location_name}): Demanda volumen={volume_demand}, Acumulado={cumulative_volume}/{volume_capacity}")
                
                # Verificar skills requeridos
                for loc in locations:
                    if loc.get('id') == location_id:
                        required_skills = set(loc.get('required_skills', []))
                        if required_skills and not required_skills.issubset(vehicle_skills):
                            missing = required_skills - vehicle_skills
                            missing_skills.append(f"Nodo {location_id} requiere: {missing}")
                        break
                
                # Guardar nombre del nodo
                node_names.append(location_name or location_id)
                
                # Verificar si se excede la capacidad en cualquier punto
                if cumulative_weight > weight_capacity:
                    msg = f"Exceso de peso en vehículo {vehicle_id} ({vehicle.get('name')}) después de nodo {location_id}: {cumulative_weight} > {weight_capacity}"
                    capacity_warnings.append(msg)
                    print(f"[ERROR] {msg}")
                        
                if cumulative_volume > volume_capacity:
                    msg = f"Exceso de volumen en vehículo {vehicle_id} ({vehicle.get('name')}) después de nodo {location_id}: {cumulative_volume} > {volume_capacity}"
                    capacity_warnings.append(msg)
                    print(f"[ERROR] {msg}")
            
            # Añadir advertencias de habilidades requeridas
            if missing_skills:
                warnings.append(f"Vehículo {vehicle_id} no tiene todas las habilidades requeridas: {missing_skills}")
            
            # Crear ruta procesada
            route_info = {
                "vehicle_id": vehicle_id,
                "vehicle_name": vehicle.get('name', f"Vehículo {i}"),
                "route": nodes,
                "node_names": node_names,
                "total_distance": route_data.get('total_distance', 0),
                "capacities": {
                    "weight": {
                        "capacity": weight_capacity,
                        "max_load": max_cumulative_weight,
                        "is_overloaded": max_cumulative_weight > weight_capacity
                    },
                    "volume": {
                        "capacity": volume_capacity,
                        "max_load": max_cumulative_volume,
                        "is_overloaded": max_cumulative_volume > volume_capacity
                    }
                }
            }
            
            # Añadir información de breaks si existe
            if route_breaks:
                route_info['scheduled_breaks'] = route_breaks
                
            routes.append(route_info)
        
        # Analizar vehículos no utilizados que podrían ser mejores opciones
        unused_vehicles = []
        used_vehicle_ids = {route.get('vehicle_id') for route in raw_solution.get('routes', [])}
        
        for v in vehicles:
            v_id = v.get('id')
            if v_id not in used_vehicle_ids:
                unused_vehicles.append({
                    "id": v_id,
                    "name": v.get('name', v_id),
                    "weight_capacity": v.get('weight_capacity', 0),
                    "volume_capacity": v.get('volume_capacity', 0),
                    "skills": v.get('skills', [])
                })
        
        # Analizar si hay vehículos no utilizados con mejores capacidades
        better_vehicles = []
        for route in routes:
            max_weight = route['capacities']['weight']['max_load']
            max_volume = route['capacities']['volume']['max_load']
            is_overloaded = route['capacities']['weight']['is_overloaded'] or route['capacities']['volume']['is_overloaded']
            
            if is_overloaded:
                for v in unused_vehicles:
                    if v['weight_capacity'] >= max_weight and v['volume_capacity'] >= max_volume:
                        better_vehicles.append({
                            "route_vehicle": route['vehicle_name'],
                            "better_vehicle": v['name'],
                            "route_demands": {"weight": max_weight, "volume": max_volume},
                            "better_capacities": {"weight": v['weight_capacity'], "volume": v['volume_capacity']}
                        })
        
        if better_vehicles and capacity_warnings:
            warnings.append("PROBLEMA CRÍTICO: Se están utilizando vehículos con capacidad insuficiente cuando hay mejores opciones disponibles")
        
        # Respuesta final
        return {
            "status": "success",
            "message": "Solución generada y validada",
            "warnings": warnings + capacity_warnings,  # Combinar todas las advertencias
            "total_distance": raw_solution.get('total_distance', 0),
            "vehicles_used": len(routes),
            "vehicles_available": len(vehicles),
            "total_demand": {
                "weight": total_weight_demand,
                "volume": total_volume_demand
            },
            "routes": routes,
            "unused_vehicles": unused_vehicles,
            "better_vehicle_options": better_vehicles
        }


# Para mantener compatibilidad con el código existente
def present_solution(raw_solution, request_data):
    return JsonSolutionPresenter.present(raw_solution, request_data)